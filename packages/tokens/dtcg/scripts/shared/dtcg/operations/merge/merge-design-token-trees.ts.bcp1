import type { DesignTokensGroup } from '../../design-token/group/design-tokens-group.ts';
import { isDesignTokensGroup } from '../../design-token/group/is-design-tokens-group.ts';
import type { DesignTokensTree } from '../../design-token/tree/design-tokens-tree.ts';
import { cascadeInheritedPropertiesOfDesignTokensTree } from '../cascade/inherited-properties/cascade-inherited-properties-of-design-tokens-tree.ts';
import {
  extendDesignTokensGroup,
  type PatchDesignTokensGroupOptions,
} from '../extends/extend-design-tokens-group.ts';
import { resolveDesignTokensTreeExtends } from '../extends/resolve/resolve-design-tokens-tree-extends.ts';

export interface MergeDesignTokenTreesOptions extends Omit<PatchDesignTokensGroupOptions, 'path'> {}

export function mergeDesignTokenTrees(
  trees: readonly DesignTokensTree[],
  options?: MergeDesignTokenTreesOptions,
): DesignTokensGroup {
  if (trees.length === 0) {
    throw new Error('Expected at least one DesignTokensTree.');
  }

  const groups: readonly DesignTokensGroup[] = trees.map(
    (tree: DesignTokensTree, index: number): DesignTokensTree => {
      tree = cascadeInheritedPropertiesOfDesignTokensTree(resolveDesignTokensTreeExtends(tree));

      if (!isDesignTokensGroup(tree)) {
        throw new Error(`Expected DesignTokensGroup at index ${index}.`);
      }

      return tree;
    },
  ) as readonly DesignTokensGroup[];

  let mergedTokens: DesignTokensGroup = groups[0];

  for (let i: number = 1; i < groups.length; i++) {
    mergedTokens = extendDesignTokensGroup(mergedTokens, groups[i], options);
  }

  return mergedTokens;
}

// export function mergeDesignTokens(
//   tokensA: DesignTokensTree,
//   tokensB: DesignTokensTree,
// ): DesignTokensGroup {
//   tokensA = cascadeInheritedPropertiesOfDesignTokensTree(resolveDesignTokensTreeExtends(tokensA));
//   tokensB = cascadeInheritedPropertiesOfDesignTokensTree(resolveDesignTokensTreeExtends(tokensB));
//
//   if (!isDesignTokensGroup(tokensA) || !isDesignTokensGroup(tokensB)) {
//     throw new Error('Expected both arguments to be DesignTokensGroup.');
//   }
//
//   return patchDesignTokensGroup(tokensA, tokensB, {
//     onConflict: 'replace',
//   });
//
//   // const {
//   //   $description: descriptionA,
//   //   $type: typeA,
//   //   $extends: extendsA,
//   //   $ref: refA,
//   //   $deprecated: deprecatedA,
//   //   $extensions: extensionsA,
//   //   ...childrenA
//   // } = tokensA;
//   //
//   // const {
//   //   $description: descriptionB,
//   //   $type: typeB,
//   //   $extends: extendsB,
//   //   $ref: refB,
//   //   $deprecated: deprecatedB,
//   //   $extensions: extensionsB,
//   //   ...childrenB
//   // } = tokensB;
//   //
//   // return {
//   //   ...tokensA,
//   //   ...tokensB,
//   // };
// }
