import { removeUndefinedProperties } from '../../../../../../../../scripts/helpers/misc/remove-undefined-properties.ts';
import type { DesignTokensGroup } from '../../design-token/group/design-tokens-group.ts';
import type { SegmentsReference } from '../../design-token/reference/types/segments/segments-reference.ts';
import { segmentsReferenceToCurlyReference } from '../../design-token/reference/types/segments/to/curly-reference/segments-reference-to-curly-reference.ts';
import { isDesignToken } from '../../design-token/token/is-design-token.ts';
import type { DesignTokensTree } from '../../design-token/tree/design-tokens-tree.ts';

export interface MergeDesignTokensGroupsOptions {
  readonly preventTokenCollision?: boolean;
  readonly path?: SegmentsReference;
}

export function mergeDesignTokensTrees(
  treeA: DesignTokensTree,
  treeB: DesignTokensTree,
  { preventTokenCollision = true, path = [] }: MergeDesignTokensGroupsOptions = {},
): DesignTokensGroup {
  if (isDesignToken(treeA)) {
    if (!isDesignToken(treeB)) {
      throw new Error('Got a DesignToken as input A, and a DesignTokensGroup as input B.');
    }

    if (preventTokenCollision) {
      throw new Error(
        `Tokens at ${segmentsReferenceToCurlyReference(path)} collide with each other.`,
      );
    }

    return {
      ...treeA,
      ...treeB,
    };
  } else {
    if (isDesignToken(treeB)) {
      throw new Error('Got a DesignTokensGroup as input A, and a DesignToken as input B.');
    }
  }

  const {
    $description: $descriptionB,
    $type: $typeB,
    $extends: $extendsB,
    $ref: $refB,
    $deprecated: $deprecatedB,
    $extensions: $extensionsB,
    ...childrenB
  } = treeB;

  if (treeA.$extends !== undefined || treeA.$ref !== undefined) {
    throw new Error('Input A should not have $extends.');
  }

  if ($extendsB !== undefined || $refB !== undefined) {
    throw new Error('Input B should not have $extends.');
  }

  return {
    ...treeA,
    ...removeUndefinedProperties({
      $description: $descriptionB,
      $typeA: $typeB,
      $deprecatedA: $deprecatedB,
      $extensionsB,
    }),
    ...Object.fromEntries(
      Object.entries(childrenB).map(
        ([name, child]: [string, DesignTokensTree]): [string, DesignTokensTree] => {
          if (Reflect.has(treeA, name)) {
            return [
              name,
              mergeDesignTokensTrees(Reflect.get(treeA, name), child, {
                preventTokenCollision,
                path: [...path, name],
              }),
            ];
          } else {
            return [name, child];
          }
        },
      ),
    ),
  };
}

// export function mergeDesignTokensTrees(
//   groupA: DesignTokensGroup,
//   groupB: DesignTokensGroup,
// ): DesignTokensGroup {
//   const {
//     $description: $descriptionA,
//     $type: $typeA,
//     $extends: $extendsA,
//     $ref: $refA,
//     $deprecated: $deprecatedA,
//     $extensions: $extensionsA,
//     ...childrenA
//   } = groupA;
//
//   const {
//     $description: $descriptionB,
//     $type: $typeB,
//     $extends: $extendsB,
//     $ref: $refB,
//     $deprecated: $deprecatedB,
//     $extensions: $extensionsB,
//     ...childrenB
//   } = groupB;
//
//
//   if ($extends !== undefined || $ref !== undefined) {
//     throw new Error('Source should not have $extends.');
//   }
//
//   if (extendedBy.$extends !== undefined || extendedBy.$ref !== undefined) {
//     throw new Error('Patch should not have $extends.');
//   }
//
//   return {
//     ...removeUndefinedProperties({
//       $description: $descriptionA,
//       $typeA: $typeA,
//       $deprecatedA: $deprecatedA,
//       $extensionsA,
//     }),
//     ...removeUndefinedProperties({
//       $description: $descriptionB,
//       $typeA: $typeB,
//       $deprecatedA: $deprecatedB,
//       $extensionsB,
//     }),
//     ...childrenA,
//     ...tokensA,
//     ...tokensB,
//   };
// }

// export function mergeDesignTokenGroups(
//   groupA: DesignTokensGroup,
//   groupB: DesignTokensGroup,
// ): DesignTokensGroup {
//   const {
//     $description: $descriptionA,
//     $type: $typeA,
//     $extends: $extendsA,
//     $ref: $refA,
//     $deprecated: $deprecatedA,
//     $extensions: $extensionsA,
//     ...childrenA
//   } = groupA;
//
//   const {
//     $description: $descriptionB,
//     $type: $typeB,
//     $extends: $extendsB,
//     $ref: $refB,
//     $deprecated: $deprecatedB,
//     $extensions: $extensionsB,
//     ...childrenB
//   } = groupB;
//
//
//   if ($extends !== undefined || $ref !== undefined) {
//     throw new Error('Source should not have $extends.');
//   }
//
//   if (extendedBy.$extends !== undefined || extendedBy.$ref !== undefined) {
//     throw new Error('Patch should not have $extends.');
//   }
//
//   return {
//     ...removeUndefinedProperties({
//       $description: $descriptionA,
//       $typeA: $typeA,
//       $deprecatedA: $deprecatedA,
//       $extensionsA,
//     }),
//     ...removeUndefinedProperties({
//       $description: $descriptionB,
//       $typeA: $typeB,
//       $deprecatedA: $deprecatedB,
//       $extensionsB,
//     }),
//     ...childrenA,
//     ...tokensA,
//     ...tokensB,
//   };
// }

// export function patchDesignTokensGroup(
//   source: DesignTokensGroup,
//   patch: DesignTokensGroup,
// ): DesignTokensGroup {
//   const { $description, $type, $extends, $ref, $deprecated, $extensions, ...children } = source;
//
//   if ($extends !== undefined || $ref !== undefined) {
//     throw new Error('Source should not have $extends.');
//   }
//
//   if (patch.$extends !== undefined || patch.$ref !== undefined) {
//     throw new Error('Patch should not have $extends.');
//   }
//
//   return {
//     ...patch,
//     ...removeUndefinedProperties({
//       $description,
//       $type,
//       $deprecated,
//       $extensions,
//     }),
//     ...Object.fromEntries(
//       Object.entries(children).map(
//         ([name, child]: [string, DesignTokensTree]): [string, DesignTokensTree] => {
//           if (Reflect.has(patch, name) && isDesignToken(child)) {
//             if (onConflict === 'throw') {
//               throw new Error(
//                 `Conflicting design tokens: ${segmentsReferenceToCurlyReference(path)}`,
//               );
//             }
//           }
//
//           if (!Reflect.has(patch, name) || isDesignToken(child)) {
//             return [name, child];
//           } else {
//             return [
//               name,
//               patchDesignTokensGroup(child, Reflect.get(patch, name), {
//                 path: [...path, name],
//                 onConflict,
//               }),
//             ];
//           }
//         },
//       ),
//     ),
//   };
// }

// export function mergeDesignTokens(
//   tokensA: DesignTokensTree,
//   tokensB: DesignTokensTree,
// ): DesignTokensGroup {
//   tokensA = cascadeInheritedPropertiesOfDesignTokensTree(resolveDesignTokensTreeExtends(tokensA));
//   tokensB = cascadeInheritedPropertiesOfDesignTokensTree(resolveDesignTokensTreeExtends(tokensB));
//
//   if (!isDesignTokensGroup(tokensA) || !isDesignTokensGroup(tokensB)) {
//     throw new Error('Expected both arguments to be DesignTokensGroup.');
//   }
//
//   return patchDesignTokensGroup(tokensA, tokensB, {
//     onConflict: 'replace',
//   });
//
//   // const {
//   //   $description: descriptionA,
//   //   $type: typeA,
//   //   $extends: extendsA,
//   //   $ref: refA,
//   //   $deprecated: deprecatedA,
//   //   $extensions: extensionsA,
//   //   ...childrenA
//   // } = tokensA;
//   //
//   // const {
//   //   $description: descriptionB,
//   //   $type: typeB,
//   //   $extends: extendsB,
//   //   $ref: refB,
//   //   $deprecated: deprecatedB,
//   //   $extensions: extensionsB,
//   //   ...childrenB
//   // } = tokensB;
//   //
//   // return {
//   //   ...tokensA,
//   //   ...tokensB,
//   // };
// }
