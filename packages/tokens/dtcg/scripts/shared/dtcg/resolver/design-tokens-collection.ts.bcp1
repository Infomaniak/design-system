import { glob, readFile } from 'node:fs/promises';
import { removeUndefinedProperties } from '../../../../../../../scripts/helpers/misc/remove-undefined-properties.ts';
import { isDesignTokenReference } from '../design-token/reference/is-design-token-reference.ts';
import { designTokenReferenceToCurlyReference } from '../design-token/reference/to/curly-reference/design-token-reference-to-curly-reference.ts';
import { designTokenReferenceToSegmentsReference } from '../design-token/reference/to/segments-reference/design-token-reference-to-segments-reference.ts';
import type { CurlyReference } from '../design-token/reference/types/curly/curly-reference.ts';
import type { ValueOrCurlyReference } from '../design-token/reference/types/curly/value-or/value-or-curly-reference.ts';
import { resolveValueOrJsonReference } from '../design-token/reference/types/json/value-or/resolve/resolve-value-or-json-reference.ts';
import type { ValueOrJsonReference } from '../design-token/reference/types/json/value-or/value-or-json-reference.ts';
import type { SegmentsReference } from '../design-token/reference/types/segments/segments-reference.ts';
import { segmentsReferenceToCurlyReference } from '../design-token/reference/types/segments/to/curly-reference/segments-reference-to-curly-reference.ts';
import { segmentsReferenceToString } from '../design-token/reference/types/segments/to/string/segments-reference-to-string.ts';
import type { ValueOrDesignTokenReference } from '../design-token/reference/value-or/value-or-design-token-reference.ts';
import { isDesignToken } from '../design-token/token/is-design-token.ts';
import type { ColorDesignTokenValue } from '../design-token/token/types/base/types/color/value/color-design-token-value.ts';
import type { ColorDesignTokenValueComponent } from '../design-token/token/types/base/types/color/value/members/components/component/color-design-token-value-component.ts';
import type { CubicBezierDesignTokenValue } from '../design-token/token/types/base/types/cubic-bezier/value/cubic-bezier-design-token-value.ts';
import type { DimensionDesignTokenValue } from '../design-token/token/types/base/types/dimension/value/dimension-design-token-value.ts';
import type { DurationDesignTokenValue } from '../design-token/token/types/base/types/duration/value/duration-design-token-value.ts';
import type { FontFamilyDesignTokenValue } from '../design-token/token/types/base/types/font-family/value/font-family-design-token-value.ts';
import { isStringFontFamilyDesignTokenValue } from '../design-token/token/types/base/types/font-family/value/types/string/is-string-font-family-design-token-value.ts';
import type { FontWeightDesignTokenValue } from '../design-token/token/types/base/types/font-weight/value/font-weight-design-token-value.ts';
import type { NumberDesignTokenValue } from '../design-token/token/types/base/types/number/value/number-design-token-value.ts';
import type { BorderDesignTokenValue } from '../design-token/token/types/composite/types/border/value/border-design-token-value.ts';
import type { GradientDesignTokenValue } from '../design-token/token/types/composite/types/gradient/value/gradient-design-token-value.ts';
import type { ShadowDesignTokenValue } from '../design-token/token/types/composite/types/shadow/value/shadow-design-token-value.ts';
import type { StrokeStyleDesignTokenValue } from '../design-token/token/types/composite/types/stroke-style/value/stroke-style-design-token-value.ts';
import { isPredefinedStrokeStyleDesignTokenValue } from '../design-token/token/types/composite/types/stroke-style/value/types/predefined/is-predefined-stroke-style-design-token-value.ts';
import type { TransitionDesignTokenValue } from '../design-token/token/types/composite/types/transition/value/transition-design-token-value.ts';
import type { TypographyDesignTokenValue } from '../design-token/token/types/composite/types/typography/value/typography-design-token-value.ts';
import { designTokensTreeSchema } from '../design-token/tree/design-tokens-tree.schema.ts';
import type { DesignTokensTree } from '../design-token/tree/design-tokens-tree.ts';

export interface DesignTokensCollectionToken {
  readonly file: string | undefined;
  readonly name: readonly string[];
  readonly type: string;
  readonly value: unknown | CurlyReference;
  readonly description: string | undefined;
  readonly deprecated: boolean | string | undefined;
  readonly extensions: object | undefined;
}

export interface DesignTokensCollectionTokensIteratorOptions {
  readonly merge?: boolean;
}

export class DesignTokensCollection {
  static #tokenNamesEqual(a: readonly string[], b: readonly string[]): boolean {
    return (
      a.length === b.length &&
      a.every((token: string, index: number): boolean => token === b[index])
    );
  }

  readonly #tokens: DesignTokensCollectionToken[];

  constructor() {
    this.#tokens = [];
  }

  /* FROM */

  async fromFiles(sources: Iterable<string>): Promise<this> {
    for (const path of sources) {
      for await (const entry of glob(path)) {
        this.fromDesignTokensTree(
          designTokensTreeSchema.parse(
            JSON.parse(
              await readFile(entry, {
                encoding: 'utf-8',
              }),
            ),
          ) as DesignTokensTree,
          entry,
        );
      }
    }

    return this;
  }

  #resolveJsonReferencesOfDesignTokenValue($type: string, $value: unknown, root: unknown): unknown {
    switch ($type) {
      case 'color':
        return this.#resolveJsonReferencesOfColorDesignTokenValue(
          $value as ColorDesignTokenValue,
          root,
        );
      case 'cubicBezier':
        return this.#resolveJsonReferencesOfCubicBezierDesignTokenValue(
          $value as CubicBezierDesignTokenValue,
          root,
        );
      case 'dimension':
        return this.#resolveJsonReferencesOfDimensionDesignTokenValue(
          $value as DimensionDesignTokenValue,
          root,
        );
      case 'duration':
        return this.#resolveJsonReferencesOfDurationDesignTokenValue(
          $value as DurationDesignTokenValue,
          root,
        );
      case 'fontFamily':
        return this.#resolveJsonReferencesOfFontFamilyDesignTokenValue(
          $value as FontFamilyDesignTokenValue,
          root,
        );
      case 'fontWeight':
        return this.#resolveJsonReferencesOfFontWeightDesignTokenValue(
          $value as FontWeightDesignTokenValue,
          root,
        );
      case 'number':
        return this.#resolveJsonReferencesOfNumberDesignTokenValue(
          $value as NumberDesignTokenValue,
          root,
        );

      case 'border':
        return this.#resolveJsonReferencesOfBorderDesignTokenValue(
          $value as BorderDesignTokenValue,
          root,
        );
      case 'gradient':
        return this.#resolveJsonReferencesOfGradientDesignTokenValue(
          $value as GradientDesignTokenValue,
          root,
        );
      case 'shadow':
        return this.#resolveJsonReferencesOfShadowDesignTokenValue(
          $value as ShadowDesignTokenValue,
          root,
        );
      case 'strokeStyle':
        return this.#resolveJsonReferencesOfStrokeStyleDesignTokenValue(
          $value as StrokeStyleDesignTokenValue,
          root,
        );
      case 'transition':
        return this.#resolveJsonReferencesOfTransitionDesignTokenValue(
          $value as TransitionDesignTokenValue,
          root,
        );
      case 'typography':
        return this.#resolveJsonReferencesOfTypographyDesignTokenValue(
          $value as TypographyDesignTokenValue,
          root,
        );
      default:
        console.warn(`Unknown token type: ${$type}.`);
        return $value;
    }
  }

  #resolveJsonReferencesOfColorDesignTokenValue(
    $value: ColorDesignTokenValue,
    root: unknown,
  ): unknown {
    return {
      colorSpace: resolveValueOrJsonReference($value.colorSpace, root),
      components: resolveValueOrJsonReference($value.components, root).map(
        (
          component: ValueOrJsonReference<ColorDesignTokenValueComponent>,
        ): ColorDesignTokenValueComponent => {
          return resolveValueOrJsonReference(component, root);
        },
      ),
      alpha: resolveValueOrJsonReference($value.alpha, root),
    };
  }

  #resolveJsonReferencesOfCubicBezierDesignTokenValue(
    $value: CubicBezierDesignTokenValue,
    root: unknown,
  ): unknown {
    return $value.map((component: ValueOrJsonReference<number>): number => {
      return resolveValueOrJsonReference(component, root);
    });
  }

  #resolveJsonReferencesOfDimensionDesignTokenValue(
    $value: DimensionDesignTokenValue,
    root: unknown,
  ): unknown {
    return {
      value: resolveValueOrJsonReference($value.value, root),
      unit: resolveValueOrJsonReference($value.unit, root),
    };
  }

  #resolveJsonReferencesOfDurationDesignTokenValue(
    $value: DurationDesignTokenValue,
    root: unknown,
  ): unknown {
    return {
      value: resolveValueOrJsonReference($value.value, root),
      unit: resolveValueOrJsonReference($value.unit, root),
    };
  }

  #resolveJsonReferencesOfFontFamilyDesignTokenValue(
    $value: FontFamilyDesignTokenValue,
    root: unknown,
  ): unknown {
    return isStringFontFamilyDesignTokenValue($value)
      ? $value
      : $value.map((component: ValueOrJsonReference<string>): string => {
          return resolveValueOrJsonReference(component, root);
        });
  }

  #resolveJsonReferencesOfFontWeightDesignTokenValue(
    $value: FontWeightDesignTokenValue,
    _root: unknown,
  ): unknown {
    return $value;
  }

  #resolveJsonReferencesOfNumberDesignTokenValue(
    $value: NumberDesignTokenValue,
    _root: unknown,
  ): unknown {
    return $value;
  }

  #resolveJsonReferencesOfCompositeDesignTokenChildValue<GValue, GNewValue>(
    valueOrReference: ValueOrDesignTokenReference<GValue>,
    resolve: (value: GValue) => GNewValue,
  ): ValueOrCurlyReference<GNewValue> {
    return isDesignTokenReference(valueOrReference)
      ? designTokenReferenceToCurlyReference(valueOrReference)
      : resolve(valueOrReference);
  }

  #resolveJsonReferencesOfBorderDesignTokenValue(
    $value: BorderDesignTokenValue,
    root: unknown,
  ): unknown {
    return {
      color: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.color,
        (value: ColorDesignTokenValue) =>
          this.#resolveJsonReferencesOfColorDesignTokenValue(value, root),
      ),
      width: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.width,
        (value: DimensionDesignTokenValue) =>
          this.#resolveJsonReferencesOfDimensionDesignTokenValue(value, root),
      ),
      style: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.style,
        (value: StrokeStyleDesignTokenValue) =>
          this.#resolveJsonReferencesOfStrokeStyleDesignTokenValue(value, root),
      ),
    };
  }

  #resolveJsonReferencesOfGradientDesignTokenValue(
    $value: GradientDesignTokenValue,
    root: unknown,
  ): unknown {
    throw 'TODO'; // TODO
  }

  #resolveJsonReferencesOfShadowDesignTokenValue(
    $value: ShadowDesignTokenValue,
    root: unknown,
  ): unknown {
    throw 'TODO'; // TODO
  }

  #resolveJsonReferencesOfStrokeStyleDesignTokenValue(
    $value: StrokeStyleDesignTokenValue,
    root: unknown,
  ): unknown {
    return isPredefinedStrokeStyleDesignTokenValue($value)
      ? $value
      : {
          dashArray: $value.dashArray.map(
            (component: ValueOrDesignTokenReference<DimensionDesignTokenValue>) => {
              return this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
                component,
                (value: DimensionDesignTokenValue) =>
                  this.#resolveJsonReferencesOfDimensionDesignTokenValue(value, root),
              );
            },
          ),
          lineCap: $value.lineCap,
        };
  }

  #resolveJsonReferencesOfTransitionDesignTokenValue(
    $value: TransitionDesignTokenValue,
    root: unknown,
  ): unknown {
    return {
      duration: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.duration,
        (value: DurationDesignTokenValue) =>
          this.#resolveJsonReferencesOfDurationDesignTokenValue(value, root),
      ),
      delay: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.delay,
        (value: DurationDesignTokenValue) =>
          this.#resolveJsonReferencesOfDurationDesignTokenValue(value, root),
      ),
      timingFunction: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.timingFunction,
        (value: CubicBezierDesignTokenValue) =>
          this.#resolveJsonReferencesOfCubicBezierDesignTokenValue(value, root),
      ),
    };
  }

  #resolveJsonReferencesOfTypographyDesignTokenValue(
    $value: TypographyDesignTokenValue,
    root: unknown,
  ): unknown {
    return {
      fontFamily: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.fontFamily,
        (value: FontFamilyDesignTokenValue) =>
          this.#resolveJsonReferencesOfFontFamilyDesignTokenValue(value, root),
      ),
      fontSize: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.fontSize,
        (value: DimensionDesignTokenValue) =>
          this.#resolveJsonReferencesOfDimensionDesignTokenValue(value, root),
      ),
      fontWeight: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.fontWeight,
        (value: FontWeightDesignTokenValue) =>
          this.#resolveJsonReferencesOfFontWeightDesignTokenValue(value, root),
      ),
      letterSpacing: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.letterSpacing,
        (value: DimensionDesignTokenValue) =>
          this.#resolveJsonReferencesOfDimensionDesignTokenValue(value, root),
      ),
      lineHeight: this.#resolveJsonReferencesOfCompositeDesignTokenChildValue(
        $value.lineHeight,
        (value: NumberDesignTokenValue) =>
          this.#resolveJsonReferencesOfNumberDesignTokenValue(value, root),
      ),
    };
  }

  fromDesignTokensTree(root: DesignTokensTree, file?: string | undefined): this {
    const explore = (path: readonly string[], tree: DesignTokensTree): void => {
      if (isDesignToken(tree)) {
        const { $value, $type, $deprecated, $description, $extensions } = tree;

        if (isDesignTokenReference($value)) {
          const reference: SegmentsReference = designTokenReferenceToSegmentsReference($value);

          try {
            const token: DesignTokensCollectionToken = this.get(reference);

            this.append({
              file,
              name: path,
              type: $type ?? token.type,
              value: segmentsReferenceToCurlyReference(reference),
              deprecated: $deprecated ?? token.deprecated,
              description: $description ?? token.description,
              extensions: $extensions ?? token.extensions,
            });
          } catch (error) {
            throw new Error(
              `Unable to resolve reference: ${segmentsReferenceToString(reference)}.`,
              {
                cause: error,
              },
            );
          }
        } else {
          if ($type === undefined) {
            throw new Error('Unable to resolve $type.');
          }

          this.append({
            file,
            name: path,
            type: $type,
            value: this.#resolveJsonReferencesOfDesignTokenValue($type, $value, root),
            deprecated: $deprecated,
            description: $description,
            extensions: $extensions,
          });
        }
      } else {
        const { $description, $type, $extends, $ref, $deprecated, $extensions, ...children } = tree;

        if ($extends !== undefined || $ref !== undefined) {
          throw new Error('Missing $extends and $ref implementation on DesignTokensGroup.'); // TODO
        }

        for (const [name, child] of Object.entries(children)) {
          explore([...path, name], {
            ...removeUndefinedProperties({ $description, $type, $deprecated, $extensions }),
            ...child,
          });
        }
      }
    };

    explore([], root);

    return this;
  }

  /* OPERATIONS */

  get size(): number {
    return this.#tokens.length;
  }

  append(token: DesignTokensCollectionToken): this {
    this.#tokens.push(token);

    return this;
  }

  delete(nameOrToken: readonly string[] | DesignTokensCollectionToken): number {
    let deleted: number = 0;
    const isTokenName: boolean = Array.isArray(nameOrToken);

    for (let i: number = 0; i < this.#tokens.length; i++) {
      const token: DesignTokensCollectionToken = this.#tokens[i];

      if (
        isTokenName
          ? DesignTokensCollection.#tokenNamesEqual(token.name, nameOrToken as readonly string[])
          : token === nameOrToken
      ) {
        this.#tokens.splice(i, 1);
        i--;
        deleted++;
      }
    }

    return deleted;
  }

  get(name: readonly string[]): DesignTokensCollectionToken {
    const token: DesignTokensCollectionToken | undefined = this.getOptional(name);

    if (token === undefined) {
      throw new Error(`Missing token: ${name.join('.')}`);
    } else {
      return token;
    }
  }

  getAll(name: readonly string[]): DesignTokensCollectionToken[] {
    return this.#tokens.filter((token: DesignTokensCollectionToken): boolean => {
      return DesignTokensCollection.#tokenNamesEqual(token.name, name);
    });
  }

  getOptional(name: readonly string[]): DesignTokensCollectionToken | undefined {
    for (let i: number = this.#tokens.length - 1; i >= 0; i--) {
      const token: DesignTokensCollectionToken = this.#tokens[i];

      if (DesignTokensCollection.#tokenNamesEqual(token.name, name)) {
        return token;
      }
    }

    return undefined;
  }

  has(nameOrToken: readonly string[] | DesignTokensCollectionToken): boolean {
    const isTokenName: boolean = Array.isArray(nameOrToken);

    for (let i: number = 0; i < this.#tokens.length; i++) {
      const token: DesignTokensCollectionToken = this.#tokens[i];

      if (
        isTokenName
          ? DesignTokensCollection.#tokenNamesEqual(token.name, nameOrToken as readonly string[])
          : token === nameOrToken
      ) {
        return true;
      }
    }

    return false;
  }

  set(token: DesignTokensCollectionToken): void {
    this.delete(token.name);
    this.append(token);
  }

  clear(): void {
    this.#tokens.length = 0;
  }

  *tokens({
    merge = true,
  }: DesignTokensCollectionTokensIteratorOptions = {}): Generator<DesignTokensCollectionToken> {
    if (merge) {
      const processed: Set<string> = new Set();

      for (let i: number = 0; i < this.#tokens.length; i++) {
        let token: DesignTokensCollectionToken = this.#tokens[i];

        const key: string = JSON.stringify(token.name);

        if (processed.has(key)) {
          continue;
        }

        processed.add(key);

        for (let j: number = this.#tokens.length - 1; j > i; j--) {
          const lastToken: DesignTokensCollectionToken = this.#tokens[j];

          if (DesignTokensCollection.#tokenNamesEqual(token.name, lastToken.name)) {
            token = lastToken;
            break;
          }
        }

        yield token;
      }
    } else {
      yield* this.#tokens;
    }
  }
}

/*------------------*/

export async function debugDesignTokensCollection(sources: Iterable<string>): Promise<void> {
  const collection: DesignTokensCollection = new DesignTokensCollection();

  await collection.fromFiles(sources);

  collection.get();
  console.log(Array.from(collection.tokens()));
}
